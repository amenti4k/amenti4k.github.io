<!-- Minimal Floating Table of Contents -->
<nav id="toc-container" class="toc-container">
    <div id="toc-nav" class="toc-nav">
        <!-- TOC will be populated by JavaScript -->
    </div>
</nav>

<style>
.toc-container {
    position: fixed;
    right: 30px;
    top: 100px;
    bottom: 50px;
    width: 200px;
    overflow-y: scroll; /* Force scrollbar to always show */
    overflow-x: hidden;
    z-index: 100;
    font-family: 'Inconsolata', monospace;
    font-size: 11px;
    line-height: 1.4;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
    scroll-behavior: smooth;
}

/* Custom scrollbar for TOC */
.toc-container::-webkit-scrollbar {
    width: 3px;
}

.toc-container::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 3px;
}

.toc-container::-webkit-scrollbar-thumb {
    background: var(--secondary-text-color, #9b9b9b);
    border-radius: 3px;
    opacity: 0.5;
}

.toc-container:hover::-webkit-scrollbar-thumb {
    background: var(--text-color, #e1e1e1);
    opacity: 0.8;
}

.toc-container.visible {
    opacity: 1;
    pointer-events: auto;
}

.toc-container.minimized {
    opacity: 0.2;
    transition: opacity 0.5s ease;
}

.toc-container.minimized:hover {
    opacity: 1;
}

.toc-nav {
    color: var(--secondary-text-color, #9b9b9b);
    padding: 5px 0;
}

.toc-nav ul {
    list-style: none;
    margin: 0;
    padding: 0;
}

.toc-nav li {
    margin: 0;
    padding: 2px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.toc-nav a {
    color: var(--secondary-text-color, #9b9b9b);
    text-decoration: none;
    transition: color 0.2s ease;
    display: block;
    border-left: 2px solid transparent;
    padding-left: 0;
}

.toc-nav a:hover {
    color: var(--text-color, #e1e1e1);
}

.toc-nav a.active {
    color: var(--text-color, #e1e1e1);
    border-left-color: var(--text-color, #e1e1e1);
}

/* Indentation for nested headings */
.toc-nav .toc-h2 {
    padding-left: 0;
    font-weight: 600;
}

.toc-nav .toc-h3 {
    padding-left: 12px;
    font-size: 10px;
}

.toc-nav .toc-h4 {
    padding-left: 24px;
    font-size: 10px;
    opacity: 0.7;
}

/* Hide on mobile */
@media (max-width: 1200px) {
    .toc-container {
        display: none;
    }
}
</style>

<script>
// Generate Table of Contents
function generateTOC() {
    const tocNav = document.getElementById('toc-nav');
    let headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
    
    if (headings.length === 0) {
        headings = document.querySelectorAll('article h2, article h3, article h4');
        if (headings.length === 0) return;
    }
    
    const tocList = document.createElement('ul');
    
    headings.forEach((heading, index) => {
        if (!heading.id) {
            heading.id = 'heading-' + index;
        }
        
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = '#' + heading.id;
        a.textContent = heading.textContent;
        a.className = 'toc-' + heading.tagName.toLowerCase();
        
        a.addEventListener('click', function(e) {
            e.preventDefault();
            const target = document.getElementById(heading.id);
            if (target) {
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                updateActiveSection(heading.id);
            }
        });
        
        li.appendChild(a);
        tocList.appendChild(li);
    });
    
    tocNav.appendChild(tocList);
}

// Update active section based on scroll
function updateActiveSection(activeId, shouldAutoScroll = true) {
    const links = document.querySelectorAll('.toc-nav a');
    let activeLink = null;
    
    links.forEach(link => {
        if (link.getAttribute('href') === '#' + activeId) {
            link.classList.add('active');
            activeLink = link;
        } else {
            link.classList.remove('active');
        }
    });
    
    // Only auto-scroll TOC if explicitly requested and user isn't manually scrolling
    if (shouldAutoScroll && activeLink && activeLink.offsetParent) {
        const tocContainer = document.getElementById('toc-container');
        
        // Check if user is hovering over TOC (indicating manual interaction)
        const isHovering = tocContainer.matches(':hover');
        if (isHovering) return; // Don't auto-scroll if user is interacting
        
        const linkRect = activeLink.getBoundingClientRect();
        const containerRect = tocContainer.getBoundingClientRect();
        
        // Only auto-scroll if the active link is completely out of view
        if (linkRect.bottom < containerRect.top || linkRect.top > containerRect.bottom) {
            const linkTop = activeLink.offsetTop;
            const linkHeight = activeLink.offsetHeight;
            const containerHeight = tocContainer.clientHeight;
            
            // Scroll to put active link in view (near top third)
            const idealScroll = linkTop - (containerHeight / 3);
            
            tocContainer.scrollTo({
                top: Math.max(0, idealScroll),
                behavior: 'smooth'
            });
        }
    }
}

// Track scroll to highlight current section
function trackScroll() {
    const expandedPost = document.querySelector('.post-content.expanded');
    let headings;
    
    if (expandedPost) {
        headings = expandedPost.querySelectorAll('h2, h3, h4');
    } else {
        headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        if (headings.length === 0) {
            headings = document.querySelectorAll('article h2, article h3, article h4');
        }
    }
    
    if (!headings || headings.length === 0) return;
    
    // Use viewport center for better tracking
    const viewportCenter = window.innerHeight / 2;
    let currentSection = null;
    let closestDistance = Infinity;
    
    headings.forEach(heading => {
        const rect = heading.getBoundingClientRect();
        const distance = Math.abs(rect.top - viewportCenter);
        
        // Find the heading closest to viewport center
        if (distance < closestDistance) {
            closestDistance = distance;
            currentSection = heading.id;
        }
    });
    
    if (currentSection) {
        updateActiveSection(currentSection);
    }
}

// Generate TOC for expanded post
function generateTOCForPost(postContent) {
    const tocNav = document.getElementById('toc-nav');
    const tocContainer = document.getElementById('toc-container');
    if (!tocNav || !tocContainer) return;
    
    tocNav.innerHTML = '';
    
    // Find all headings - be very thorough
    let headings = postContent.querySelectorAll('h1, h2, h3, h4');
    
    // If no headings found, try looking deeper in the DOM
    if (headings.length === 0) {
        console.log('No headings found directly, searching deeper...');
        const allElements = postContent.getElementsByTagName('*');
        const headingElements = [];
        for (let el of allElements) {
            if (/^H[1-4]$/.test(el.tagName)) {
                headingElements.push(el);
            }
        }
        headings = headingElements;
    }
    
    console.log('Found ' + headings.length + ' headings in expanded post');
    
    // Debug: log first few headings
    if (headings.length > 0) {
        console.log('First heading:', headings[0].tagName, headings[0].textContent);
        if (headings.length > 1) {
            console.log('Second heading:', headings[1].tagName, headings[1].textContent);
        }
        console.log('Last heading:', headings[headings.length - 1].tagName, headings[headings.length - 1].textContent);
    }
    
    if (headings.length === 0) {
        tocContainer.classList.remove('visible');
        return;
    }
    
    const tocList = document.createElement('ul');
    
    headings.forEach((heading, index) => {
        // Skip any H1 headings (main titles)
        if (heading.tagName === 'H1') {
            console.log('Skipping H1:', heading.textContent);
            return; // Skip all H1s
        }
        
        if (!heading.id) {
            // Create clean ID from heading text
            const cleanText = heading.textContent.trim()
                .replace(/[^a-zA-Z0-9\s]/g, '') // Remove special chars
                .replace(/\s+/g, '-') // Replace spaces with hyphens
                .toLowerCase()
                .substring(0, 50); // Limit length
            heading.id = 'toc-' + cleanText + '-' + index;
        }
        
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = '#' + heading.id;
        
        // Truncate long headings
        let text = heading.textContent.trim();
        if (text.length > 30) {
            text = text.substring(0, 27) + '...';
        }
        a.textContent = text;
        a.title = heading.textContent; // Full text on hover
        a.className = 'toc-' + heading.tagName.toLowerCase();
        
        a.addEventListener('click', function(e) {
            e.preventDefault();
            const target = document.getElementById(heading.id);
            if (target) {
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                updateActiveSection(heading.id);
            }
        });
        
        li.appendChild(a);
        tocList.appendChild(li);
    });
    
    tocNav.appendChild(tocList);
    
    // Show TOC with animation
    tocContainer.classList.add('visible');
    
    // Force reset scroll position to absolute top
    setTimeout(() => {
        tocContainer.scrollTop = 0;
        console.log('Reset TOC scroll to top');
    }, 50);
    
    // Auto-minimize after 3 seconds
    setTimeout(() => {
        tocContainer.classList.add('minimized');
    }, 3000);
    
    // DO NOT auto-scroll on initial load - let user see the full TOC
    // Only start tracking after user starts scrolling
    let hasScrolled = false;
    const scrollHandler = function() {
        if (!hasScrolled) {
            hasScrolled = true;
            // Start tracking only after first scroll
            trackScroll();
        }
    };
    window.addEventListener('scroll', scrollHandler, { once: true });
}

// Watch for post expansion
function watchPostExpansion() {
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.target.classList && mutation.target.classList.contains('post-content')) {
                const tocContainer = document.getElementById('toc-container');
                if (mutation.target.classList.contains('expanded')) {
                    // Add longer delay for large posts to ensure content is fully rendered
                    setTimeout(() => {
                        generateTOCForPost(mutation.target);
                    }, 500);
                } else {
                    if (tocContainer) {
                        tocContainer.classList.remove('visible');
                        tocContainer.classList.remove('minimized');
                    }
                }
            }
        });
    });
    
    document.querySelectorAll('.post-content').forEach(function(element) {
        observer.observe(element, { attributes: true, attributeFilter: ['class'] });
    });
}

// Initialize TOC when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    if (document.querySelector('.post-list')) {
        watchPostExpansion();
        
        const expandedPost = document.querySelector('.post-content.expanded');
        if (expandedPost) {
            // Longer delay for initial load to ensure content is fully rendered
            setTimeout(() => {
                generateTOCForPost(expandedPost);
            }, 600);
        }
        
        let scrollTimer;
        window.addEventListener('scroll', function() {
            if (scrollTimer) clearTimeout(scrollTimer);
            scrollTimer = setTimeout(trackScroll, 50);
        });
    } else if (document.querySelector('.post-content')) {
        generateTOC();
        const tocContainer = document.getElementById('toc-container');
        if (tocContainer) {
            tocContainer.classList.add('visible');
            setTimeout(() => {
                tocContainer.classList.add('minimized');
            }, 3000);
        }
        
        let scrollTimer;
        window.addEventListener('scroll', function() {
            if (scrollTimer) clearTimeout(scrollTimer);
            scrollTimer = setTimeout(trackScroll, 50);
        });
        
        trackScroll();
    }
});
</script>