<!-- Minimal Floating Table of Contents -->
<nav id="toc-container" class="toc-container">
    <div id="toc-nav" class="toc-nav">
        <!-- TOC will be populated by JavaScript -->
    </div>
</nav>

<style>
.toc-container {
    position: fixed;
    right: 30px;
    top: 100px;
    bottom: 50px;
    width: 200px;
    overflow-y: auto;
    overflow-x: hidden;
    z-index: 100;
    font-family: 'Inconsolata', monospace;
    font-size: 11px;
    line-height: 1.4;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
}

/* Custom scrollbar for TOC */
.toc-container::-webkit-scrollbar {
    width: 3px;
}

.toc-container::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 3px;
}

.toc-container::-webkit-scrollbar-thumb {
    background: var(--secondary-text-color, #9b9b9b);
    border-radius: 3px;
    opacity: 0.5;
}

.toc-container:hover::-webkit-scrollbar-thumb {
    background: var(--text-color, #e1e1e1);
    opacity: 0.8;
}

.toc-container.visible {
    opacity: 1;
    pointer-events: auto;
}

.toc-container.minimized {
    opacity: 0.2;
    transition: opacity 0.5s ease;
}

.toc-container.minimized:hover {
    opacity: 1;
}

.toc-nav {
    color: var(--secondary-text-color, #9b9b9b);
    padding: 5px 0;
}

.toc-nav ul {
    list-style: none;
    margin: 0;
    padding: 0;
}

.toc-nav li {
    margin: 0;
    padding: 2px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.toc-nav a {
    color: var(--secondary-text-color, #9b9b9b);
    text-decoration: none;
    transition: color 0.2s ease;
    display: block;
    border-left: 2px solid transparent;
    padding-left: 0;
}

.toc-nav a:hover {
    color: var(--text-color, #e1e1e1);
}

.toc-nav a.active {
    color: var(--text-color, #e1e1e1);
    border-left-color: var(--text-color, #e1e1e1);
}

/* Indentation for nested headings */
.toc-nav .toc-h2 {
    padding-left: 0;
    font-weight: 600;
}

.toc-nav .toc-h3 {
    padding-left: 12px;
    font-size: 10px;
}

.toc-nav .toc-h4 {
    padding-left: 24px;
    font-size: 10px;
    opacity: 0.7;
}

/* Hide on mobile */
@media (max-width: 1200px) {
    .toc-container {
        display: none;
    }
}
</style>

<script>
// Generate Table of Contents
function generateTOC() {
    const tocNav = document.getElementById('toc-nav');
    let headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
    
    if (headings.length === 0) {
        headings = document.querySelectorAll('article h2, article h3, article h4');
        if (headings.length === 0) return;
    }
    
    const tocList = document.createElement('ul');
    
    headings.forEach((heading, index) => {
        if (!heading.id) {
            heading.id = 'heading-' + index;
        }
        
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = '#' + heading.id;
        a.textContent = heading.textContent;
        a.className = 'toc-' + heading.tagName.toLowerCase();
        
        a.addEventListener('click', function(e) {
            e.preventDefault();
            const target = document.getElementById(heading.id);
            if (target) {
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                updateActiveSection(heading.id);
            }
        });
        
        li.appendChild(a);
        tocList.appendChild(li);
    });
    
    tocNav.appendChild(tocList);
}

// Update active section based on scroll
function updateActiveSection(activeId) {
    const links = document.querySelectorAll('.toc-nav a');
    let activeLink = null;
    
    links.forEach(link => {
        if (link.getAttribute('href') === '#' + activeId) {
            link.classList.add('active');
            activeLink = link;
        } else {
            link.classList.remove('active');
        }
    });
    
    // Scroll the TOC container to keep active item visible (but not on every update)
    if (activeLink && activeLink.offsetParent) {
        const tocContainer = document.getElementById('toc-container');
        const linkRect = activeLink.getBoundingClientRect();
        const containerRect = tocContainer.getBoundingClientRect();
        
        // Only auto-scroll if the active link is not visible
        if (linkRect.top < containerRect.top || linkRect.bottom > containerRect.bottom) {
            const linkTop = activeLink.offsetTop;
            const linkHeight = activeLink.offsetHeight;
            const containerHeight = tocContainer.clientHeight;
            
            // Scroll to put active link in the middle of the container
            const idealScroll = linkTop - (containerHeight / 2) + (linkHeight / 2);
            
            tocContainer.scrollTo({
                top: Math.max(0, idealScroll),
                behavior: 'smooth'
            });
        }
    }
}

// Track scroll to highlight current section
function trackScroll() {
    const expandedPost = document.querySelector('.post-content.expanded');
    let headings;
    
    if (expandedPost) {
        headings = expandedPost.querySelectorAll('h2, h3, h4');
    } else {
        headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        if (headings.length === 0) {
            headings = document.querySelectorAll('article h2, article h3, article h4');
        }
    }
    
    if (!headings || headings.length === 0) return;
    
    // Use viewport center for better tracking
    const viewportCenter = window.innerHeight / 2;
    let currentSection = null;
    let closestDistance = Infinity;
    
    headings.forEach(heading => {
        const rect = heading.getBoundingClientRect();
        const distance = Math.abs(rect.top - viewportCenter);
        
        // Find the heading closest to viewport center
        if (distance < closestDistance) {
            closestDistance = distance;
            currentSection = heading.id;
        }
    });
    
    if (currentSection) {
        updateActiveSection(currentSection);
    }
}

// Generate TOC for expanded post
function generateTOCForPost(postContent) {
    const tocNav = document.getElementById('toc-nav');
    const tocContainer = document.getElementById('toc-container');
    if (!tocNav || !tocContainer) return;
    
    tocNav.innerHTML = '';
    
    const headings = postContent.querySelectorAll('h2, h3, h4');
    
    if (headings.length === 0) {
        tocContainer.classList.remove('visible');
        return;
    }
    
    const tocList = document.createElement('ul');
    
    headings.forEach((heading, index) => {
        if (!heading.id) {
            heading.id = 'heading-' + Date.now() + '-' + index;
        }
        
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = '#' + heading.id;
        
        // Truncate long headings
        let text = heading.textContent;
        if (text.length > 30) {
            text = text.substring(0, 27) + '...';
        }
        a.textContent = text;
        a.title = heading.textContent; // Full text on hover
        a.className = 'toc-' + heading.tagName.toLowerCase();
        
        a.addEventListener('click', function(e) {
            e.preventDefault();
            const target = document.getElementById(heading.id);
            if (target) {
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                updateActiveSection(heading.id);
            }
        });
        
        li.appendChild(a);
        tocList.appendChild(li);
    });
    
    tocNav.appendChild(tocList);
    
    // Show TOC with animation
    tocContainer.classList.add('visible');
    
    // Reset scroll position to top
    tocContainer.scrollTop = 0;
    
    // Auto-minimize after 3 seconds
    setTimeout(() => {
        tocContainer.classList.add('minimized');
    }, 3000);
    
    // Initial tracking after a short delay to ensure DOM is ready
    setTimeout(() => {
        trackScroll();
    }, 100);
}

// Watch for post expansion
function watchPostExpansion() {
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.target.classList && mutation.target.classList.contains('post-content')) {
                const tocContainer = document.getElementById('toc-container');
                if (mutation.target.classList.contains('expanded')) {
                    generateTOCForPost(mutation.target);
                } else {
                    if (tocContainer) {
                        tocContainer.classList.remove('visible');
                        tocContainer.classList.remove('minimized');
                    }
                }
            }
        });
    });
    
    document.querySelectorAll('.post-content').forEach(function(element) {
        observer.observe(element, { attributes: true, attributeFilter: ['class'] });
    });
}

// Initialize TOC when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    if (document.querySelector('.post-list')) {
        watchPostExpansion();
        
        const expandedPost = document.querySelector('.post-content.expanded');
        if (expandedPost) {
            generateTOCForPost(expandedPost);
        }
        
        let scrollTimer;
        window.addEventListener('scroll', function() {
            if (scrollTimer) clearTimeout(scrollTimer);
            scrollTimer = setTimeout(trackScroll, 50);
        });
    } else if (document.querySelector('.post-content')) {
        generateTOC();
        const tocContainer = document.getElementById('toc-container');
        if (tocContainer) {
            tocContainer.classList.add('visible');
            setTimeout(() => {
                tocContainer.classList.add('minimized');
            }, 3000);
        }
        
        let scrollTimer;
        window.addEventListener('scroll', function() {
            if (scrollTimer) clearTimeout(scrollTimer);
            scrollTimer = setTimeout(trackScroll, 50);
        });
        
        trackScroll();
    }
});
</script>